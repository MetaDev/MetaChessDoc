Coding


general: implement as moba, with as much parameters as possible
simple but highly parametric
-NO AI
-no mouse control, keyboard only is more elegant, like playing a piano, a controller is of course possible


-add gui to server code (2 buttons start/stop)
-send movement messages between several clients connected to server
-simple client server
-simple working online multiplayer, using ip adresses
-refactoring decision mapping


-todo
-ooit nog is cooldown dubbelchecken
-check if team makes a decision every main-turn
-seperate piece logic and model
-maak een set met locking decisions en een set van decision with cooldown, met daarin dan direct het gewicht vd cooldownS

-pawn binding
-implement completely the lowest fraction functionallity

-back to networking
multiple players of same team-> switching
-every main turn, 1 non-controlled piece makes a random move. from each side
-the pawn's around the king can only disconnect by voting, if the majority of the pawns choose for the same direction (choosing between up, upleft, down,...), they can make 1 liberating move
-verhaal afschrijven
-once beta is complete make site

-for each piece unique mapping allowed
-make sure that cooldown is proportioned to tile fracioning of the tile it's standing on
-not a minimum turn -time will be enforced but a maximum fractioning of the turn-time, is about the same. this smallest fraction is of course not absolute
but the turn -time won't be further fractioned, and movement becomes real-time.
-the cooldown is saved in absolute amount of turns on the smalles fraction: formula: smallestfraction/fraction * turnsactive * range * weight
-after every turn passed on the smallest fraction the cooldown is lowered
-watch out for cooldown milking, that is that the player cools down on a low fraction and just before the turns change on the low fraction it goes up to a lower fraction
to also collect this cooldwon. To counter this a cooldown is only reduced after a full turn on the same fraction, so after the second turnchange on the same fraction

-create standard constructors for piece models

-refactor renderers, use bitgrid instead of subclasses


-when on lowest fraction and tileview is so high that all tiles can be seen, lower tileview so that just all tiles can be seen
-when reaching a turn-time that is too small to play on ( min is 1/60 second, 1 game loop) change the game to real-time: don't lock anymore
-keep in mind for an offline mode, to debug
-there is only 1 range

-settings gui: choose side, turn time, start game, join server...
-implement that when 2 pieces of same color come on same tile-> fraction
-when 2 pieces go "through" each other the tile where they meet is fractioned with a number that is as big as needed to complete the move
and avoid collision eg they are on neighbour tiles and move in towards each other with 1 tile, the fraction is 2 tiles 
they move toward each other with 3 tiles -> the fraction is 8 tiles always do roundtonearestpowerof2(2*tilesleft to move)
change: only fraction if the sum of the remaining moves when the pieces meet is a power of 2. if not the piece can't pass through each other, so they don't move.




-if 2 piece of opposite side come on same tile, delete

-implenteer dat eens de speler zo'n hoge fractioning bereikt dat het realtime wordt dat alles van cooldowns vermenigvuldigt wordt met minTurnTime
Behalve voor de beweging deze heeft geen cooldown meer, maar dan moet ook een deel van de mapping van de keys verandert worden en dan moet hold niet 
meer toegelaten zijn voor movement registratie;



-implement change of piece with core(maybe keep in mind that different ways of switching piece should be possible eg nearest, strongest, furthest,...), not indefinetly
-cooldown of switch is equal to number of tiles in gaussian distance





-een pion kan maar 1 beweging, als er een stuk in aanvals richting is, dan zal deze met een beweging dit stuk automatisch aanvallen, als er 2
stukke aangevallen kunnen worden, dan wordt het sterkste gedoodt


-metaactions die moeten werken, reduce view, movement, switch piece, change turn
-alle piece types moeten werken

-teken stukken ook met bitgrid

-refactoring all those methods in actionlogic would be a good idea: 
use decision weight, balance, model side to get the value, and the saved valueobjects to execute the correct getter or setter
remove ugly Method objects and work without enums for actions
-make a destinction between piece specific decision and not piece specific
- a decision only execute 1 method so far, maybe remove the possibility to execute multiple methods?
-piece movement types: orthog, diagonal and knight
-map movement types to piece types
-de bewegings acties uitbreiden met string, string gebruiken om de int[][] met directions op the halen, veel schaalbaarder

-decision work ubt should be done better
make a queue on which a detected decision is noted
the piecemodel then clear this queue on every metaloop
sketch this first before trying to change
opsplitsen van bestaande code van makedecision bij player
zodat het gemakkelijker is om multipayer decisions te maken


-all piece types should work

- een website met allemaal competitieve 2d spellen zoals metachess en andere. In die site zijn 3 reeksen, regular, amateur, professional. De amateur krijgt grafische customisatie van de kern
, color mapping. Pro krijgt toegang tot training(confusion, visual, sound), bootcamp. also sponsor account: pay and manage teams of player. Every account has a different fee.
Regular is free, amateur is the fee low so that when you play and win enough you can pay for it. Pro you have to play a lot or pay. Sponsor always has to pay
naam: www.aregameswith.tk  -> betekenis: where, where, where are games with telekenisis.
op deze website zullen deze spellen nooit veranderen. alleen de parameters binnen de spellen kunnen wijzigen om de gameplay haarfijn af te stellenS


-to implement mouse control: cast mouse x and y to an i and j in the tileview, us this i and j to "move" from the player's tile to the pointed tile

-implement the watcher with a simple chess AI, the watcher only knows chess rules,AI for The Two Players(chess engine)


add gui: 
-in gui show the turn by 2 levels, the current tile and parent tile, this is to know how long you'll have to wait when you leave a fraction
-auto-adapt gui:pas aantal tegels in gui aan, aan de ruimte die het krijgt: altijd 8 in de grootste maat (hoogte, breedte) en dan x in de andere maat, met x anderemaat/(maat/8) ,
dus eigenlijk aantal tegels dat er andere maat bij zouden passen

-maak gui pas zicht baar vanaf een bepaalde verhouding hoogte/ breedte gui >= aantal kolommen/rijen gui, zodat elke tegel in de gui goed zichtbaar is
-de gebruiker kan het aantal rijen en kolommen dan manueel aanpassen
-de gebruiker zou ook moeten kunnen kiezen wat er in de gui getoond wordt
-TEST!!!! let people play 1vs1, 2vs2, 4vs2, 1vs4,.... let them note what they think about the game how they would improve
what they like/dislike about it,.... 
-alles wat in een editor klasse is geÃ¯mplementeerd zou in feite aanpasbaar moeten zijn in een gui die altijd aanspreekbaar moet zijn,
deze gui bedenkt wel het speelveld

REFACTORING:
-data acces pattern for all singletons like board, renderers,....
-refactor actions with  valueobjects
splis code:in pieceextended model staat te veel logica, dat moet allemaal in een andere klasse
-de beurten kloppen nog niet, er zijn maar half zo veel beurten als er gefractioned is, bug misschien
-create method to retreive method from a string
-save Piece directions as constant
-checking if a turn changed on a tile should be done more effecient
-make a method division of ints in metaUtil
-centreer de guitile numbers, dat is mooier

-eventually the player should have list from which he can choose decisions
-when pawns form formations they unlock or strengthen!(more reach, or more weight) decisions
-a decision (MetaAction) should have a "weight" variable, and a "reach" (reach should be a number of tiles, then you can either reach in a line(1 direction) or a circle(all directions), but the same amount of tiles
-"reach" of decision is changed with number buttons, just like range of movement, if a decision is made and the reach is > 1 then it's a ranged decision
-split logic between metaAction activity and turnsactive


-metaactions die moeten werken, fixed tileview, max tileview, max movement , fixed movement, max decision range, fixed decision range
-extra parameter for decision , fixate (set fixed for var param)or plafonate (macximum fixeren) or reduce (normal, works with balance)
-finish gui

-finish all metaActions:

things like rangeup1, 2, 4,... will be 1 action rangeup but the variable will be changeable of course through points, points which will be given through achievements
like: reaching the other side eg +2 points, killing a piece of x lives + 2*x points, finding the gray pawn +10 pointsn,.....


-todo: griddrawer: save drawing, reset (load last), load drawing, edit nr of columns,rows


-add UI to choose button config
-ooit is een doc schrijven + maak van die doc een wiskundig manifesto waarin abstract alle regels van het spel beschreven staan


-in gui moet er een mogelijkheid zijn: fillGUI die de ruimte optimaal benut: zo veel mogelijk gui tiles toont in de gekregen guiruimte

find a better name for core-> axis, better name MetaAction->decision
-use gray only for the gray pawn, or everything that has nothing to do with "pure" chess, that is not bounded by the rules of chess!!!!->metactions
-tileextendedmodel hier de logica opsplitsen




-in het kickstarter project laat iedereen stemmen door 1 euro te doneren voor een bepaalde uitbreiding van het prototype
of 5 euro voor een server met het spel en die krijgen dan een account. Iemand die 7 of meer stemmen uitbrengt krijgt ook een account
-dit account geldt op de site voor al mijn komende projecten



-check if diag mov works correct
-option to turn off specatt's


-if something is implemented in todo and counts as a rule add to rules, this will be the base of manual
-uniform use of keys for all pieces, restrict to define different piece style inputs
-implement mouse control
-implement simple turn based rythm music 
-N
-GUI: shows remaining lives,  tile depth, tile fractioning/abs fractioning, specatt's ,..., show if move is already made, show how long you have to wait until next move

-make simple single player, where with a working 1 vs CPU. begin met origin of war
-the player can switch between peices (with it's core) 

-bass toon elke keer een beurt voorbij is, een beetje geluid in integreren
-een passerende stukken (ze springen langs elkaar ipv op elkaar) geeft geluid van passerende trienen.


-sync board changes (by specatt)

-implement some simple game modes, to test gameplay:
-1 vs 1, each has a "super"-piece, or a kind of switch between pieces is possible like fifa
-2 vs 2
-....-> maybe a setting GUI where all options for gamemodes are available to change?

-recursive turn time, done. But due to the exponential increase decrease it becomes very fast unplayable, maybe changing the rules a bit? fraction the time by level and not by fraction

-add the story to the game, try to finish this part, so that this can be used as prototype on the kickstarter project
tell the story from the document until you reach the point where the piece discover their core
hide this story within the moba, the story only becomes available when the grey pawn is caught, it's an implicit quest inside every moba session, like a red line(de rode draad), the grey pawn is very hard to find and even harder to catch
Een core verliest al zijn geheugen als hij de continuiteit verlaat, daarom dat hij vecht tegen stukken en niet meer weet van waar hij komt, toon in soms existentiele vragen van de stukken om 
te suggereren dat er meer is dan alleen de moba

vervolg, nadat de stukken ontdekken dat ze hun kern van hun stuk kunnen verwijderen kiezen veel stukken ervoor om in continuiteit te leven en het eeuwige strijdveld van 
metachess te verlaten, maar sommige kernen voelen zich avontuurlijk en willen hun bevrijder eren door de oorlog na te spelen:

regels
er zijn zoveel cores als er spelers zijn.
Een stuk zonder core can niet gedood worden.
Een core kan van stuk veranderen maar niet ongelimiteerd.
stukken zonder core kunnen gecontroleerd worden door controlling entities, eenmaal per main cycle en ook slechts 1 stuk per main cycle.

(moba)
Game: Origin of War (there is none)
Spel begint op main fraction
De gray pawn berijdt 1 pion, met die pion moet de speler dan meer stukken bevrijden.
Niet bevrijde stukken kunnen zonder core ook gedood worden.8
Je moet proberen om zoveel mogelijk stukken te 'bevrijden' , van je eigen kleur, door samen met die stukken fractions te creeeren.
In die fractions krijgen ze de mogelijkheid tot een eigen wil.
Zodat als je wisselt van stuk je deze stukken ook kan gebruiken
Specatt's worden geleerd door punten, punten kunnen verdiend worden door mekaar te doden.
Het spel eindigt wanneer alle cores van 1 team vernietigt zijn.
Een core heeft een zekere hoeveelheid levensenergie.
als een core gedood wordt in een pion dan verliest het 1/8 van zijn levens, als het sterft in een paard 1/2 in een koning 1 leven.
In de originele versie van origin of war heb je maar 1 leven


(RPG part, implicit quest in every OoW session)
Game: Search for Gray
Het spel begint al op een zekere diepte. 
Dit is de diepte net voor de continuiteit.
Zo kan je steeds naar een hogere diepte gaan, overal zijn willekeurige lege stukken, verlaten door hun core.
Specatt's worden geleerd door een in een stuk te wisselen die een bepaalde specatt beheerste.
(hier start de impl quest, de hierboven beschreven game-modus wordt vrijgespeeld als de grijze pion is gevonden)
De bedoeling is de grijze pion te vinden.
ergens op een willekeurig tegel op een willekeurige, misschien nog niet bestaande, diepte. (geef een indicatie van waar hij is)




extra:
{
-native analog controller support
from a dream
-extra pieces: dragon/snake (s-movement), fox (sneaky) ,...
-maybe add a specatt like the ability to change into animals
-design numeric GUI + Design gui icons
-code mouse control, show possible moves with a cross on tile, if clicked on it the piece will move there
-> this can bes used to play on the same computer, one player on the keyboard one with the mouse, mutliple screens, splitscreen like lego ps3?
-recode queen and king control, such that they only move when a key is released, and diag mov is done when an appriopriate key is pressed while realeasing
-inverse control: use numpad to move and numbers on keyboard for values
recode the board
-new implementation of the boardlogic
-change floor implementation from recursive to iterative with arrays (a finite dimensional array) 
example new code with arrays, I don't know if this is more efficient, but it surely makes easier code
Object[][] test  = new Object[8][8];
		test[1][2]=new Object[8][8];
		((Object[][])test[1][2])[0][0]=1;
-don't delete recursive implementation keep both-> recursive logic, iterative logic
-to check if tile is occupied, don't save in a tile. 
rather use an array of coordinates and an array of fractions for drawin. the recursive properties of the tiles will handle the movement
}
-finish special attacks

-implement AI (finish)

-> under here maybe not, keep meta chess a moba, implement new engine and write the rpg for that
-start design rpg world (crude)

-implement world (crude)

-make world online (with own server/client code, optimize prvious implementation)

-integrate flexible(variable) chess battle game inside world

-refine world, add quest, npc's, buildings?, enemies (AI)

-make a html5 client, to play the game in a browser

-make an android app

-effects:

-camera effect (make a slow transition)
-add shadow 
-3D rendering?
-3D viewing?

Cleaning
-duplicate code in controllers
-make floor a singleton
-test effecienty of both board implementations
-tile shouldn't keep width and x, only the first size and it's absolute fraction and it's relative i and j pos
-A piece also shouldn't save it's tile.


New project

cRayOn

alles wordt getekend met lijnen, kunst, maak zelf engine en gebruik wiskundige functies om alle dingen te tekenen en collsion checken,...
een soort van kleurpotlood wereld, gebruik hiervoor opengl en 3d projectie net als in immersieve tech

UniPoly


Het doel van het spel is om in elke sector alles zo eerlijk mogelijk te verdelen
Hoe dichter jouw aandeel bij een natuurlijke breuk is met als noemer het aantal aandeelhouders, hoe groter je divident.



MetaMonopoly

*a pseudo-economy based 2d board game, this time it's an rpg.
core principles: there are streets like in monopoly (cyclic) you can go from one street to another. 
A player has a vehicle, this vehicle is the center of the rpg, it can be extended, upgraded, parts added,...
every vehicle has it's own fuel and fuel is made out of basic products, that's where the economy is:
a vehicle uses fuel, a station sells fuel, a station needs basic products, a mine mines basic products, a vehicle transports basic products to a station
make it absurd, use psuedo-chemy in a pseudo-economy with vehicles based on pseudo-mechanics
a player can own buildings that create revenues, explore uncharted terrain, build new streets, transport, race against other players,...


*implement dot engine

use bozels for physics (box2d)
and lwjgl for graphics

use the smilhelm world(triangle) for 3 factions
use confuse for quests in the smilhelm story line